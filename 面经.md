# 自我介绍（技术面）：

​		您好，我叫罗英伟，目前就读于上海理工大学计算机科学与技术专业，面试岗位为Java后端实习。大学期间我成绩优异并拥有丰富的竞赛经历，获得过***，除此之外我拥有丰富的项目经历，在我的Github主页上记录了我大大小小十几个项目仓库，其中云点餐项目参加过微信小程序开发大赛并取得了优异的成绩，另一个智e体检项目，是一个队列调度优化的排队系统，曾经在计算机应用能力大赛获得过上海市二等奖。不过，在我所有项目中最具综合性的是一个微服务架构的电商系统，它的原型是一个拉新营销平台，集成了电商系统所具有的大部分功能，比如企业级注册登录方案，JWT登陆过期-自动刷新token功能的实现，新用户注册自动领取优惠券的业务功能，分布式锁，分布式事务的使用等等，这个项目在我的仓库中累计有60多次的提交记录，目前还在不断地完善中。以上是我的项目经历介绍，
​		最后，很荣幸参加今天的面试，其实我从小就对汽车挺感兴趣，小时候就能认清马路上跑的大部分轿车的牌子，而蔚来又是中国汽车领域的佼佼者，希望我能有去蔚来实习的机会



# 索引的概念和底层实现原理

​		索引（Index）是帮助数据库高效获取数据的数据结构。索引是在基于数据库表创建的，它包含一个表中某些列的值以及记录对应的地址，并且把这些值存储在一个数据结构中，在进行数据库查询时使用索引，可以加速数据的查询。因为索引是有序排列的。最常见的就是使用哈希表、B+树作为索引。

**数据库索引有哪些呢？**
1.聚集索引（主键索引）：在数据库里面，所有行数都会按照主键索引进行排序。

2.非聚集索引：就是给普通字段加上索引。

3.联合索引：就是好几个字段组成的索引，称为联合索引。
		复合索引在数据库操作期间所需的开销更小，可以代替多个单一索引;   同时有两个概念叫做**窄索引**和**宽索引**，窄索引是指索引列为1-2列的索引，宽索引也就是索引列超过2列的索引;   
设计索引的一个重要原则就是能用窄索引不用宽索引，因为窄索引往往比组合索引更有效;

创建复合索引 ：

```sql
CREATE INDEX columnId ON table1(col1,col2,col3) ;
```

查询语句： 

```
select * from table1 where col1= A and col2= B and col3 = C
```

这时候查询优化器，不在扫描表了，而是直接的从索引中拿数据,因为索引中有这些数据，这叫**覆盖式查询**，这样的查询速度非常快; 

**索引使用注意事项**

- 不要滥用索引：索引提高查询速度，却会降低更新表的速度，因为更新表时，mysql不仅要更新数据，保存数据，还要更新索引，保存索引；索引会占用磁盘空间 
- 索引不会包含含有NULL值的列：复合索引只要有一列含有NULL值，那么这一列对于此符合索引就是无效的，因此我们在设计数据库设计时不要让字段的默认值为NULL。 
- MySQL查询只是用一个索引：如果where字句中使用了索引的话，那么order by中的列是不会使用索引的 
- like：like '%aaa%'不会使用索引而like "aaa%"可以使用索引，通配符"%" 可匹配0个或多个字符



# MySQL中的常见索引

- **INDEX（普通索引）**：ALTER TABLE 'table_name' ADD INDEX index_name('col')最基本的索引，没有任何限制 
- **UNIQUE（唯一索引）**：ALTER TABLE 'table_name' ADD UNIQUE('col')，与“普通索引”类似，不同的就是：索引列的值必须唯一，但允许有空值。 
- **PRIMARY KEY（主键索引）**：ALTER TABLE 'table_name' ADD PRIMARY KEY('col') 是一种特殊的唯一索引，不允许有空值。 
- **FULLTEXT（全文索引）**：ALTER TABLE 'table_name' ADD FULLTEXT('col')，仅可用于MyISAM和InoDB，针对较大的数据，生成全文索引很耗时耗空间
- **组合索引**：ALTER TABLE 'table_name' ADD INDEX index_name('col1','col2','col3')
  为了更多的提高mysql效率可建立组合索引，遵循“最左前缀”原则。创建复合索引应该将最常用（频率）做限制条件的列放在最左边，依次递减。组合索引最左字段用in是可以用到索引的。相当于建立了col1，col1col2，col1col2col3三个索引。



# 索引失效的情况和原理

表student中两个字段age,name加了索引

```sql
key ``'idx_age'``(``'age'``),
key ``'idx_name'` `(``'name'``)
```

 1.Like这种就是%在前面的不走索引，在后面的走索引（A走索引，B不走索引）

```
A:select * from student where 'name' like '王%'
B:select * from student where 'name' like '%小'
```

 2.用索引列进行计算的，不走索引（A走索引，B不走索引）

```
A:select * from student where age = 10+8
B:select * from student where age + 8 = 18
```

 3.对索引列用函数了，不走索引（A不走索引，B走索引）

```
A:select * from student where  concat('name','哈') ='王哈哈';
B:select * from student where name = concat('王哈','哈');
```

4.索引列用了!= 不走索引

```
select * from student where age != 18
```

 5.索引字段进行判空查询时。也就是对索引字段判断是否为NULL时

```
select * from student where name is null
```

 6.随着表的增长，where条件出来的数据太多，大于15%，使得索引失效

 7.避免在where子句中使用`or`来连接条件,因为如果俩个字段中有一个没有索引的话,引擎会放弃索引而产生全表扫描

```
SELECT id FROM table WHERE num = 0 OR num = 1
```





# 索引B+树的叶子节点都可以存哪些东西

**或问聚簇索引与非聚簇索引的区别**

可能存储的是整行数据，也有可能是主键的值。

B+树的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。而索引B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引。

聚簇索引
所谓聚簇索引，就是指主索引文件和数据文件为同一份文件，聚簇索引主要用在Innodb存储引擎中。在该索引实现方式中B+Tree的叶子节点上的data就是数据本身，key为主键，如果是一般索引的话，data便会指向对应的主索引。

非聚簇索引
非聚簇索引就是指B+Tree的叶子节点上的data，并不是数据本身，而是数据存放的地址。主索引和辅助索引没啥区别，只是主索引中的key一定得是唯一的，主要用在MyISAM存储引擎中。非聚簇索引比聚簇索引多了一次读取数据的IO操作，所以查找性能上会差。

覆盖索引
指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。

注意：
MySQL InnoDB一定会建立聚簇索引，把实际数据行和相关的键值保存在一块，这也决定了一个表只能有一个聚簇索引，即MySQL不会一次把数据行保存在二个地方。

InnoDB通常根据主键值(primary key)进行聚簇
如果没有创建主键，则会用一个唯一且不为空的索引列做为主键，成为此表的聚簇索引
上面二个条件都不满足，InnoDB会自己创建一个虚拟的聚集索引
正因为InnoDB将数据保存在一处，因此其插入速度严重依赖插入顺序。按照主键顺序插入无疑是最快的。如果不是按照主键插入，建议加载完成后最好使用OPTIMIZE TABLE重新组织一下表。



# MySQL的一级索引和二级索引

一级索引：
索引和数据存储在一起，都存储在同一个B+树中的叶子节点。一般主键索引都是一级索引。

二级索引：
二级索引树的叶子节点存储的是主键而不是数据。也就是说，在找到索引后，得到对应的主键，再回到一级索引中找主键对应的数据记录。

一级索引和二级索引的关系：回表
一级索引可以单独存在，二级索引不能单独存在，必须依附于一级索引，这叫做“回表”。



# 操作系统—互斥锁、自旋锁、读写锁、悲观锁、乐观锁

**一、互斥锁：**
使用场景： 如果你能确定被锁住的代码执行时间很长，就不应该用互斥锁
		加锁的目的就是保证共享资源在任意时间里，只有一个线程访问，这样就可以避免多线程导致共享数据错乱的问题。
		互斥锁加锁失败后，线程会释放 CPU ，给其他线程，自身处于获取锁阻塞状态，然后从用户态切换到内核态由由内核帮助进行切换线程，当加锁失败时，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机唤醒线程，当这个线程成功获取到锁后，于是就可以继续执行，这之间的过程会产生上下文切换。

- 获取锁失败的线程会从Running(运行态) - > Sleep(睡眠态），然后把CPU切换给其他线程运行
- 当锁被释放后，线程会从Sleep（睡眠态） -> Ready(就绪)状态，然后内核把CPU切换给该进

上下文切换的过程，虚拟内存是共享的，需要保存线程的私有数据，寄存器等不共享的数据。



**二、自旋锁**
使用场景： 如果你能确定被锁住的代码执行时间很短，就使用自旋锁

自旋锁是通过CPU函数在用户态完成加锁和解锁操作，不产生上下文切换， 但是自旋锁会产生忙等待，自旋的线程会占用消耗CPU资源。此种加锁方式只适合于分时系统，不能工作在单CPU的硬件

- 第一步，查看所得状态，如果锁空闲，执行第二步
- 第二步，将锁设置为当前线程所持有



**三、读写锁**
使用场景：读写锁适用于能明确区分读操作和写操作的场景
		当「写锁」没有被线程持有时，多个线程能够并发地持有读锁，这大大提高了共享资源的访问效率，因为「读锁」是用于读取共享资源的场景，所以多个线程同时持有读锁也不会破坏共享资源的数据。但是，一旦「写锁」被线程持有后，读线程的获取读锁的操作会被阻塞，而且其他写线程的获取写锁的操作也会被阻塞
		因为读不影响资源，但是某一线程写入的时候会使其他线程对该资源的读写操作有影响，所以有**读优先锁**和**写优先锁**两种模式。
		**公平读写锁** ： 比较简单的一种方式是：用队列把获取锁的线程排队，不管是写线程还是读线程都按照先进先出的原则加锁即可，这样读线程仍然可以并发，也不会出现「饥饿」的现象。



**四、乐观锁 和 悲观锁**
前面提到的互斥锁、自旋锁、读写锁，都是属于悲观锁。
		**悲观锁**做事比较悲观，它认为多线程同时修改共享资源的概率比较高，因此很容易产生冲突，所以访问共享资源前先上锁。
		**乐观锁**做事比较乐观，它假定冲突的概率很低，它的工作方式是：先修改完共享资源，再验证这段时间内有没有发生冲突，如果没有其他线程在修改资源，那么操作完成，如果发现有其他线程已经修改过这个资源，就放弃本次操作。





# 核心知识-ThreadLocal介绍+经典应用场景

* 什么是ThreadLocal

```
全称thread local variable（线程局部变量）功用非常简单，使用场合主要解决多线程中数据因并发产生不一致问题。

ThreadLocal为每一个线程都提供了变量的副本，使得每个线程在某时间访问到的并不是同一个对象，这样就隔离了多个线程对数据的数据共享，这样的结果是耗费了内存，但大大减少了线程同步所带来性能消耗，也减少了线程并发控制的复杂度。 

总结起来就是：同个线程共享数据

注意：ThreadLocal不能使用原子类型，只能使用Object类型
```



* 核心应用场景

```
ThreadLocal 用作每个线程内需要独立保存信息，方便同个线程的其他方法获取该信息的场景。

每个线程获取到的信息可能都是不一样的，前面执行的方法保存了信息后，后续方法可以通过ThreadLocal 直接获取到，避免了传参，类似于全局变量的概念，比如用户登录令牌解密后的信息传递（还有用户权限信息、从用户系统获取到的用户名、用户ID）
```

![image-20210204002205526](E:/typora_img/image-20210204002205526.png)

* 用户微服务配置token解密信息传递

```
public static ThreadLocal<LoginUser> threadLocal = new ThreadLocal<>();


                LoginUser loginUser = new LoginUser();
                loginUser.setId(id);
                loginUser.setName(name);
                loginUser.setMail(mail);
                loginUser.setHeadImg(headImg);
                threadLocal.set(loginUser);
```

# P6面试题：ThreadLocal和Synchronized的区别 

* 都是为了解决多线程中相同变量的访问冲突问题
* Synchronized是通过线程等待，牺牲时间来解决访问冲突
* ThreadLocal是通过每个线程单独一份存储空间，牺牲空间来解决冲突，
* 对比Synchronized，ThreadLocal具有线程隔离的效果，只有在线程内才能获取到对应的值，线程外则不能访问到想要的值



# P6面试题：为啥什么ThreadLocal的键是弱引用，如果是强引用有什么问题？

Java中除了基础的数据类型以外，其它的都为引用类型。
而Java根据其生命周期的长短将引用类型又分为强引用 、 软引用 、 弱引用 、 虚引用
正常情况下我们平时基本上我们只用到强引用类型，而其他的引用类型我们也就在面试中，或者平日阅读类库或其他框架源码的时候才能见到

1、强引用 new了一个对象就是强引用  Object obj = new Object();
JVM宁可抛出OOM也不会回收强引用类型对象

2、软引用的生命周期比强引用短一些,通过SoftReference类实现，当内存空间足够，垃圾回收器就不会回收它; 当JVM认为内存空间不足时，就会去试图回收软引用指向的对象，也就是说在JVM抛出OutOfMemoryError之前，会去清理软引用对象
主要用来描述一些【有用但并不是必需】的对象
使用场景：适合用来实现缓存，内存空间充足的时候将数据缓存在内存中，如果空间不足了就将其回收掉


3、弱引用是通过WeakReference类实现的，它的生命周期比软引用还要短，在GC的时候，不管内存空间足不足都会回收这个对象
使用场景：一个对象只是偶尔使用，希望在使用时能随时获取，但也不想影响对该对象的垃圾收集，则可以考虑使用弱引用来指向该对象。


**ThreadLocal为什么是WeakReference呢？**

如果是强引用，即使把ThreadLocal设置为null，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal不会被回收，导致Entry内存泄漏

如果是弱引用
引用ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。value在下一次ThreadLocalMap调用set、get、remove的时候会被清除。

